/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options {
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

import java.io.*;
import com.google.gson.*;
import com.google.gson.stream.*;
import Main.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/

    public static void main(String[] args) throws ParseException {

        String esprima = read_esprima();

        //System.out.print(esprima);

        InputStream esprimaStream = new ByteArrayInputStream(esprima.getBytes());

        try{esprimaStream.close();}
        catch (IOException e) {
            e.printStackTrace();
        }

        Parser myCalc = new Parser(esprimaStream);
        SimpleNode root = myCalc.Expression();
        root.dump("");

        //System.out.println("Valor da express\u00e3o: "+myCalc.eval(root));
    }

    public static String read_esprima(){
        File file = new File("esprima.txt");
        FileInputStream fis = null;

        Gson gson = new Gson();
        JsonReader reader;
        try{
            reader = new JsonReader(new FileReader("esprima.txt"));
            Main init = gson.fromJson(reader, Main.class);
            init.print();
        } catch(FileNotFoundException err){

        }
        String content= new String(); //para o texto mesmo
        int newContent; //para cada byte que vai ser lido

        try {
            fis = new FileInputStream(file);

            while ((newContent = fis.read()) != -1) {
                // convert to char and display it
                // System.out.print((char) content);

                char newContentArray[] = {(char)newContent}; //para poder criar String
                content += new String(newContentArray, 0, 1); //1 porque com fis e so 1 a 1
            }


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null){

                    return content;
                }

                fis.close();

            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

        return null;
    }

}


PARSER_END(Parser)

SKIP :
{
    " " | "\r" | "\t" | "{" | "}" | "[" | "]"
    | "\"" |  "\n" | ":" | ","
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < WORD: ((["A"-"Z"])+(["a"-"z"])+ )+> //so comeca com maiusculas

    | < TYPE: "type">
    | < BODY: "body">
    | < DECLARATIONS: "declarations" >
    | < ID: "id" >
    | < INIT: "init" >
    | < OPERATOR: "operator" >
    | < LEFT: "left" >
    | < RIGHT: "right" >
    | < VALUE: "value" >
    | < RAW: "raw" >
    | < KIND: "kind" >
    | < SOURCE_TYPE: "sourceType" >
}

SimpleNode Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
    {/*@bgen(jjtree) Expression */
            try {
/*@egen*/
            <TYPE> <WORD> BodyExpr()/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
            } catch (Throwable jjte000) {
              if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte000 instanceof RuntimeException) {
                throw (RuntimeException)jjte000;
              }
              if (jjte000 instanceof ParseException) {
                throw (ParseException)jjte000;
              }
              throw (Error)jjte000;
            } finally {
              if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
              }
            }
/*@egen*/
    }

    void BodyExpr()      : {/*@bgen(jjtree) body */
  SimpleNode jjtn000 = new SimpleNode(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
    {/*@bgen(jjtree) body */
        try {
/*@egen*/
        <BODY> (TypeExpr())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

    void TypeExpr()      :
    {/*@bgen(jjtree) type */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
        Token t;
    }
    {/*@bgen(jjtree) type */
        try {
/*@egen*/
        <TYPE>
        t=<WORD>/*@bgen(jjtree) type_name */
                 {
                   SimpleNode jjtn001 = new SimpleNode(JJTTYPE_NAME);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*//*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtc001 = false;
                 }
/*@egen*/ {
            System.out.println(t.image);
        }/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001, true);
                   }
                 }
/*@egen*/           /*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
