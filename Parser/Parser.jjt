options {
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

import java.io.*;
import com.google.gson.*;
import com.google.gson.stream.*;
import Main.*;
import com.*;
import Objects.*;

public class Parser{

    public static void main(String[] args) throws ParseException {

        String esprima = read_esprima();

        //System.out.print(esprima);

        InputStream esprimaStream = new ByteArrayInputStream(esprima.getBytes());

        try{esprimaStream.close();}
        catch (IOException e) {
            e.printStackTrace();
        }

        Parser myCalc = new Parser(esprimaStream);
        SimpleNode root = myCalc.Expression();
        root.dump("");

        //System.out.println("Valor da express√£o: "+myCalc.eval(root));
    }

    public static String read_esprima(){
        File file = new File("esprima.txt");
        FileInputStream fis = null;

        NodeDeserializer typeAdapter = new NodeDeserializer();
        Gson gson = new GsonBuilder()
                            .registerTypeAdapter(Node.class, typeAdapter)
                            .registerTypeAdapter(Reference.class, typeAdapter)
                            .registerTypeAdapter(Expression.class, typeAdapter)
                            .create();
        JsonReader reader;
        try{
            reader = new JsonReader(new FileReader("esprima.txt"));
            Main init = gson.fromJson(reader, Main.class);
            init.print();
        } catch(FileNotFoundException err){

        }
        String content= new String(); //para o texto mesmo
        int newContent; //para cada byte que vai ser lido

        try {
            fis = new FileInputStream(file);

            while ((newContent = fis.read()) != -1) {
                // convert to char and display it
                // System.out.print((char) content);

                char newContentArray[] = {(char)newContent}; //para poder criar String
                content += new String(newContentArray, 0, 1); //1 porque com fis e so 1 a 1
            }


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null){

                    return content;
                }

                fis.close();

            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

        return null;
    }

}


PARSER_END(Parser)

SKIP :
{
    " " | "\r" | "\t" | "{" | "}" | "[" | "]"
    | "\"" |  "\n" | ":" | ","
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < WORD: ((["A"-"Z"])+(["a"-"z"])+ )+> //so comeca com maiusculas

    | < TYPE: "type">
    | < BODY: "body">
    | < DECLARATIONS: "declarations" >
    | < ID: "id" >
    | < INIT: "init" >
    | < OPERATOR: "operator" >
    | < LEFT: "left" >
    | < RIGHT: "right" >
    | < VALUE: "value" >
    | < RAW: "raw" >
    | < KIND: "kind" >
    | < SOURCE_TYPE: "sourceType" >
}

SimpleNode Expression(): {}
    {
            <TYPE> <WORD> BodyExpr() {return jjtThis;}
    }

    void BodyExpr() #body: {}
    {
        <BODY> (TypeExpr())+
    }

    void TypeExpr() #type:
    {
        Token t;
    }
    {
        <TYPE>
        t=<WORD> {
            System.out.println(t.image);
        } #type_name
    }
